val STATE_NOT_STARTED = 0;
val STATE_RUNNING = 1;
val STATE_GAME_OVER = 2;
val STATE_PAUSE = 3;

val DIR_UP = 1;
val DIR_RIGHT = 2;
val DIR_DOWN = 3;
val DIR_LEFT = 4;

// TODO: Fix colors.
val BGCOLOR = RGB(50i8, 50i8, 50i8);
val FGCOLOR = RGB(-50i8, -50i8, -50i8);
val SNAKE_COLOR = RGB(0i8, -80i8, 0i8);
val APPLE_COLOR = RGB(-50i8, 0i8, 0i8);

val CELL_SIZE = 20;
// Odd numbers so we can put the snake smack in the middle of the screen (for the start screen to look better).
val ROWS = 25;
val COLS = 25;
val WINDOW_WIDTH = CELL_SIZE * ROWS;
val WINDOW_HEIGHT = CELL_SIZE * COLS;


struct Point {
  row: int;
  col: int;
}

struct State {
  cellSize: int;
  rows: int;
  cols: int;

  gameState: int;

  snakePositions: []Point;
  snakeLength: int;
  direction: int;
  applePosition: Point;
}


func main(): int {
  var state: State;

  Init(&state);

  InitWindow(WINDOW_WIDTH, WINDOW_HEIGHT, cstr("Pirx Snake - Press any key to start"));
  SetTargetFPS(8);

  while !WindowShouldClose() {
    DoUpdate(&state);
    BeginDrawing();
    DoDrawing(&state);
    EndDrawing();
  }
  CloseWindow();

  Cleanup(&state);

  return 0;
}

func Init(state: *State) {
  state.gameState = STATE_NOT_STARTED;

  state.snakePositions = new([]Point, ROWS * COLS);
  state.snakeLength = 1;
  state.direction = DIR_RIGHT;

  // Start at the center.
  state.snakePositions[0].row = ROWS / 2;
  state.snakePositions[0].col = COLS / 2;

  PlaceApple(state);
}

func Cleanup(state: *State) {
  dispose(state.snakePositions);
}

// *** Game state updates ***

func DoUpdate(state: *State) {
  if state.gameState == STATE_NOT_STARTED {
    var key = GetKeyPressed();
    if key != 0 {
      // User pressed any key -> start the game.
      SetGameState(state, STATE_RUNNING);
    }
    return;
  }

  if state.gameState == STATE_RUNNING {
    UpdateRunningGame(state);
  }

  if state.gameState == STATE_GAME_OVER {
    var key = GetKeyPressed();
    if key != 0 {
      // User pressed any key -> reset the state and start a new game.
      Init(state);
      SetGameState(state, STATE_NOT_STARTED);
    }
    return;
  }

  if state.gameState == STATE_PAUSE {
    var key = GetKeyPressed();
    // Unpause the game on any key.
    if key != 0 {
      SetGameState(state, STATE_RUNNING);
    }
  }
}

func SetGameState(state: *State, gameState: int) {
  state.gameState = gameState;
  if state.gameState == STATE_NOT_STARTED {
    SetWindowTitle(cstr("Pirx Snake - Press any key to start"));
  } else if state.gameState == STATE_RUNNING {
    SetWindowTitle(cstr("Pirx Snake"));
  } else if state.gameState == STATE_GAME_OVER {
    SetWindowTitle(cstr("Pirx Snake - Game Over!"));
  } else if state.gameState == STATE_PAUSE {
    SetWindowTitle(cstr("Pirx Snake - Pause"));
  }
}

func UpdateRunningGame(state: *State) {
  // Handle user input.
  var key = GetKeyPressed();
  if key == KEY_SPACE {
    SetGameState(state, STATE_PAUSE);
    return;
  }

  if key == KEY_UP {
    if state.direction != DIR_DOWN {
      state.direction = DIR_UP;
    }
  } else if key == KEY_RIGHT {
    if state.direction != DIR_LEFT {
      state.direction = DIR_RIGHT;
    }
  } else if key == KEY_DOWN {
    if state.direction != DIR_UP {
      state.direction = DIR_DOWN;
    }
  } else if key == KEY_LEFT {
    if state.direction != DIR_RIGHT {
      state.direction = DIR_LEFT;
    }
  }

  // Calculate the new position of the head.
  var newHead = state.snakePositions[0];
  if state.direction == DIR_UP {
    newHead.row--;
  } else if state.direction == DIR_RIGHT {
    newHead.col++;
  } else if state.direction == DIR_DOWN {
    newHead.row++;
  } else if state.direction == DIR_LEFT {
    newHead.col--;
  }

  // Wrap around.
  newHead.row = WrapCoord(newHead.row, ROWS);
  newHead.col = WrapCoord(newHead.col, COLS);

  if CollidesWithSnake(state, newHead.row, newHead.col) {
    GameOver(state);
    return;
  }

  // Check if we got the apple.
  if newHead.row == state.applePosition.row && newHead.col == state.applePosition.col {
    state.snakeLength++;
    PlaceApple(state);
  }

  // Shift the snake body.
  for var i = state.snakeLength-1; i > 0; i-- {
    state.snakePositions[i] = state.snakePositions[i-1];
  }

  // Update the head.
  state.snakePositions[0] = newHead;
}

func PlaceApple(state: *State) {
  while true {
    var row = GetRandomValue(0, ROWS-1);
    var col = GetRandomValue(0, COLS-1);
    if CollidesWithSnake(state, row, col) {
      continue;
    }
    // Do not generate an apple on the same position twice.
    if state.applePosition.row == row && state.applePosition.col == col {
      continue;
    }
    state.applePosition.row = row;
    state.applePosition.col = col;
    break;
  }
}

func CollidesWithSnake(state: *State, row: int, col: int): bool {
  for var i = 0; i < state.snakeLength; i++ {
    if state.snakePositions[i].row == row && state.snakePositions[i].col == col {
      return true;
    }
  }
  return false;
}

func GameOver(state: *State) {
  SetGameState(state, 2); // STATE_GAME_OVER
}

// *** Drawing ***

func DoDrawing(state: *State) {
  ClearBackground(BGCOLOR);
  DrawGrid(state);
  DrawSnake(state);
  DrawApple(state);
}

func DrawGrid(state: *State) {
  for var i = 0; i < COLS - 1; i++ {
    var x = CELL_SIZE * (i+1);
    DrawLine(x, 0, x, WINDOW_HEIGHT-1, FGCOLOR);
  }
  for var i = 0; i < ROWS - 1; i++ {
    var y = CELL_SIZE * (i+1);
    DrawLine(0, y, WINDOW_WIDTH-1, y, FGCOLOR);
  }
}

func DrawCell(state: *State, row: int, col: int, color: Color) {
  var x = col * CELL_SIZE;
  var y = row * CELL_SIZE;
  DrawRectangle(x, y, CELL_SIZE-1, CELL_SIZE-1, color);
}

func DrawSnake(state: *State) {
  for var i = 0; i < state.snakeLength; i++ {
    DrawCell(state, state.snakePositions[i].row, state.snakePositions[i].col, SNAKE_COLOR);
  }
}

func DrawApple(state: *State) {
  DrawCell(state, state.applePosition.row, state.applePosition.col, APPLE_COLOR);
}

func WrapCoord(value: int, max: int): int {
  if value < 0 {
    return max-1;
  } else if value >= max {
    return 0;
  }
  return value;
}
